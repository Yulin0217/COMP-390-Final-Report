\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{adjust\PYGZus{}alpha}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{new\PYGZus{}transform}\PYG{p}{):}
\PYG{+w}{      }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{      Adjusts the smoothing factor alpha based on the difference}
\PYG{l+s+sd}{      between the new transform and the current transform to}
\PYG{l+s+sd}{      better adapt to recent data changes.}

\PYG{l+s+sd}{      Parameters:}
\PYG{l+s+sd}{      new\PYGZus{}transform (float): The new data point used to}
\PYG{l+s+sd}{      update the transform.}
\PYG{l+s+sd}{      \PYGZdq{}\PYGZdq{}\PYGZdq{}}
      \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{} Calculate the absolute difference between the current}
      \PYG{c+c1}{\PYGZsh{} and new transforms}
      \PYG{n}{error} \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{new\PYGZus{}transform} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{)}
      \PYG{c+c1}{\PYGZsh{} Dynamically adjust alpha based on the error,}
      \PYG{c+c1}{\PYGZsh{} inversely scaling it}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{alpha} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{min\PYGZus{}alpha}\PYG{p}{,} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{max\PYGZus{}alpha}\PYG{p}{,}
      \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{error}\PYG{p}{)))}

\PYG{k}{def} \PYG{n+nf}{update}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{new\PYGZus{}transform}\PYG{p}{):}
\PYG{+w}{      }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{      Updates the current transform with a new data point using}
\PYG{l+s+sd}{      adaptive exponential smoothing.}

\PYG{l+s+sd}{      Parameters:}
\PYG{l+s+sd}{      new\PYGZus{}transform (float): The new data point to incorporate}
\PYG{l+s+sd}{      into the smoothed data.}

\PYG{l+s+sd}{      Returns:}
\PYG{l+s+sd}{      float: The updated transform value.}
\PYG{l+s+sd}{      \PYGZdq{}\PYGZdq{}\PYGZdq{}}
      \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{} If no transform has been set yet, initialize it}
      \PYG{c+c1}{\PYGZsh{} with the new transform}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform} \PYG{o}{=} \PYG{n}{new\PYGZus{}transform}
      \PYG{k}{else}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{} Adjust alpha based on the new data point}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{adjust\PYGZus{}alpha}\PYG{p}{(}\PYG{n}{new\PYGZus{}transform}\PYG{p}{)}
      \PYG{c+c1}{\PYGZsh{} Apply the adjusted alpha to compute}
      \PYG{c+c1}{\PYGZsh{} the new smoothed transform}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{alpha} \PYG{o}{*} \PYG{n}{new\PYGZus{}transform} \PYG{o}{+}
      \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{alpha}\PYG{p}{)} \PYG{o}{*} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform}
      \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform}
\end{Verbatim}
